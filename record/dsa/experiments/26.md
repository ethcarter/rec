### **EXPERIMENT 26**
> *Searching*  
*DSA*

---
---

#### **Aim of the experiment:**
> To implement symbol table operations using balanced search trees

---

#### **Program:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Symbol {
    char name[20];
    int value;
    struct Symbol* left;
    struct Symbol* right;
    int height;
};

int getHeight(struct Symbol* node) {
    return node ? node->height : 0;
}

int max(int a, int b) {
    return (a > b) ? a : b;
}

struct Symbol* createSymbol(char* name, int value) {
    struct Symbol* node = (struct Symbol*)malloc(sizeof(struct Symbol));
    strcpy(node->name, name);
    node->value = value;
    node->left = node->right = NULL;
    node->height = 1;
    return node;
}

struct Symbol* rightRotate(struct Symbol* y) {
    struct Symbol* x = y->left;
    struct Symbol* T2 = x->right;
    x->right = y;
    y->left = T2;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    return x;
}

struct Symbol* leftRotate(struct Symbol* x) {
    struct Symbol* y = x->right;
    struct Symbol* T2 = y->left;
    y->left = x;
    x->right = T2;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    return y;
}

int getBalance(struct Symbol* node) {
    return node ? getHeight(node->left) - getHeight(node->right) : 0;
}

struct Symbol* insert(struct Symbol* node, char* name, int value) {
    if (!node) return createSymbol(name, value);
    
    int cmp = strcmp(name, node->name);
    if (cmp < 0) node->left = insert(node->left, name, value);
    else if (cmp > 0) node->right = insert(node->right, name, value);
    else return node;
    
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));
    int balance = getBalance(node);
    
    if (balance > 1 && strcmp(name, node->left->name) < 0)
        return rightRotate(node);
    if (balance < -1 && strcmp(name, node->right->name) > 0)
        return leftRotate(node);
    if (balance > 1 && strcmp(name, node->left->name) > 0) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    if (balance < -1 && strcmp(name, node->right->name) < 0) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
    return node;
}

struct Symbol* search(struct Symbol* root, char* name) {
    if (!root) return NULL;
    int cmp = strcmp(name, root->name);
    if (cmp == 0) return root;
    if (cmp < 0) return search(root->left, name);
    return search(root->right, name);
}

void inorder(struct Symbol* root) {
    if (root) {
        inorder(root->left);
        printf("%s: %d\n", root->name, root->value);
        inorder(root->right);
    }
}

int main() {
    struct Symbol* root = NULL;
    
    root = insert(root, "alpha", 10);
    root = insert(root, "beta", 20);
    root = insert(root, "gamma", 30);
    root = insert(root, "delta", 40);
    
    printf("Symbol Table:\n");
    inorder(root);
    
    struct Symbol* result = search(root, "beta");
    printf("\nSearch 'beta': %s\n", result ? "Found" : "Not Found");
    if (result) printf("Value: %d\n", result->value);
    
    return 0;
}
```

---

#### **Sample Output:**
```
Symbol Table:
alpha: 10
beta: 20
delta: 40
gamma: 30

Search 'beta': Found
Value: 20
```

---

#### **Conclusion:**
> Balanced search trees maintain O(log n) operations for efficient symbol table management