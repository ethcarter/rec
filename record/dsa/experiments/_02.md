<br>
<h3 align=center><b>DSA | EXPERIMENT 02</b></h3>
<br>

---

#### **Aim of the experiment:**
> To compare the time complexity of basic operations on arrays and linked lists.

---

#### **Theory:**
Arrays and linked lists are two fundamental linear data structures. Their efficiency differs based on the type of operation:

**Arrays (vectors in C++):**
- Contiguous memory allocation.
- Fast random access in O(1).
- Insertion/deletion at the end in O(1) amortized, but at the beginning or middle in O(n).

**Linked Lists:**
- Non-contiguous nodes linked by pointers.
- No direct indexing; traversal is O(n).
- Insertions and deletions at beginning or end in O(1).

**Key difference:**
- Choice depends on whether random access or frequent insertions/deletions are required.

---

#### **Program:**
```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace chrono;

const int N = 50000; // reduced for deletions (to avoid long run times)

int main() {
    // ================= ARRAY (vector) =================
  vector<int> arr;

    // Insert at end
    auto start = high_resolution_clock::now();
    for (int i = 0; i < N; i++) arr.push_back(i); // O(1) amortized
    auto end = high_resolution_clock::now();
    cout << "Array insert (end): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Insert at beginning
    start = high_resolution_clock::now();
    for (int i = 0; i < 1000; i++) arr.insert(arr.begin(), i); // O(n)
    end = high_resolution_clock::now();
    cout << "Array insert (beginning, 1000 ops): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Search
    start = high_resolution_clock::now();
    auto it = find(arr.begin(), arr.end(), N - 1); // O(n)
    end = high_resolution_clock::now();
    cout << "Array search: "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Deletion from end
    start = high_resolution_clock::now();
    for (int i = 0; i < N; i++) arr.pop_back(); // O(1)
    end = high_resolution_clock::now();
    cout << "Array deletion (end): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";


    // ================= LINKED LIST =================
    list<int> ll;

    // Insert at end
    start = high_resolution_clock::now();
    for (int i = 0; i < N; i++) ll.push_back(i); // O(1)
    end = high_resolution_clock::now();
    cout << "Linked List insert (end): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Insert at beginning
    start = high_resolution_clock::now();
    for (int i = 0; i < 1000; i++) ll.push_front(i); // O(1)
    end = high_resolution_clock::now();
    cout << "Linked List insert (beginning, 1000 ops): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Search
    start = high_resolution_clock::now();
    auto it2 = find(ll.begin(), ll.end(), N - 1); // O(n)
    end = high_resolution_clock::now();
    cout << "Linked List search: "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    // Deletion from end
    start = high_resolution_clock::now();
    for (int i = 0; i < N; i++) ll.pop_back(); // O(1)
    end = high_resolution_clock::now();
    cout << "Linked List deletion (end): "
         << duration_cast<milliseconds>(end - start).count() << " ms\n";

    return 0;
}
```

#### **Sample Output:**
```cpp
Array insert (end): 4 ms
Array insert (beginning, 1000 ops): 12 ms
Array search: 3 ms
Array deletion (end): 2 ms
Linked List insert (end): 5 ms
Linked List insert (beginning, 1000 ops): 0 ms
Linked List search: 6 ms
Linked List deletion (end): 3 ms
```

---

#### **Conclusion:**
- Arrays are efficient for random access and end insertions/deletions.
- Linked lists are more efficient for frequent insertions at the beginning, but slower in searching.
- Performance differences observed confirm theoretical time complexities.