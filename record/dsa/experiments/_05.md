<br>
<h3 align=center><b>DSA | EXPERIMENT 05</b></h3>
<br>

---

#### **Aim of the experiment:**
> To implement stack and queue operations using linked lists.

---

#### **Theory:**
Stacks and queues are abstract data types (ADTs) that can be implemented using linked lists for dynamic memory usage and efficient operations.

- **Stack (LIFO – Last In First Out):**
  - Insertion and deletion happen only at the top.
  - **Operations:**
    - **Push:** Insert element at the top.
    - **Pop:** Remove element from the top.
    - **Peek:** Return the top element without removing.

- **Queue (FIFO – First In First Out):**
  - Insertion happens at the rear, deletion at the front.
  - **Operations:**
    - **Enqueue:** Insert element at the rear.
    - **Dequeue:** Remove element from the front.
    - **Peek:** Return the front element without removing.

**Advantages of Linked List Implementation:**
- No fixed size (dynamic memory).
- Avoids overflow unless memory is exhausted.
- Efficient insertion and deletion.

---

#### **Program:**
```cpp
#include <bits/stdc++.h>
using namespace std;

// Node structure
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(NULL) {}
};

// ---------------- STACK USING LINKED LIST ----------------
class Stack {
    Node* top;
public:
    Stack() : top(NULL) {}

    void push(int val) {
        Node* newNode = new Node(val);
        newNode->next = top;
        top = newNode;
    }

    void pop() {
        if (!top) {
            cout << "Stack Underflow\n";
            return;
        }
        Node* temp = top;
        top = top->next;
        delete temp;
    }

    void peek() {
        if (!top) cout << "Stack is empty\n";
        else cout << "Top element: " << top->data << "\n";
    }

    void display() {
        Node* temp = top;
        while (temp) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
};

// ---------------- QUEUE USING LINKED LIST ----------------
class Queue {
    Node* front;
    Node* rear;
public:
    Queue() : front(NULL), rear(NULL) {}

    void enqueue(int val) {
        Node* newNode = new Node(val);
        if (!rear) {
            front = rear = newNode;
            return;
        }
        rear->next = newNode;
        rear = newNode;
    }

    void dequeue() {
        if (!front) {
            cout << "Queue Underflow\n";
            return;
        }
        Node* temp = front;
        front = front->next;
        if (!front) rear = NULL;
        delete temp;
    }

    void peek() {
        if (!front) cout << "Queue is empty\n";
        else cout << "Front element: " << front->data << "\n";
    }

    void display() {
        Node* temp = front;
        while (temp) {
            cout << temp->data << " -> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
};

int main() {
    cout << "=== STACK OPERATIONS ===\n";
    Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    s.display();
    s.pop();
    s.display();
    s.peek();

    cout << "\n=== QUEUE OPERATIONS ===\n";
    Queue q;
    q.enqueue(1);
    q.enqueue(2);
    q.enqueue(3);
    q.display();
    q.dequeue();
    q.display();
    q.peek();

    return 0;
}
```

---

#### **Sample Output:**
```cpp
=== STACK OPERATIONS ===
30 -> 20 -> 10 -> NULL
20 -> 10 -> NULL
Top element: 20

=== QUEUE OPERATIONS ===
1 -> 2 -> 3 -> NULL
2 -> 3 -> NULL
Front element: 2
```

---

#### **Conclusion:**
- Stack implemented using linked list supports dynamic push and pop operations with efficient memory usage.
- Queue implemented using linked list allows dynamic enqueue and dequeue operations without size limitations.
- Both structures confirm their respective behaviors: LIFO for stack, FIFO for queue.
