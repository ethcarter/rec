<br>
<h3 align=center><b>DSA | EXPERIMENT 05</b></h3>
<br>

---

#### **Aim of the experiment:**
> To implement stack and queue operations using linked lists.

---

#### **Program:**
```c
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

struct Node* createNode(int val) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    newNode->data = val;
    newNode->next = NULL;
    return newNode;
}

// ---------------- STACK USING LINKED LIST ----------------
struct Stack {
    struct Node* top;
};

void initStack(struct Stack* s) {
    s->top = NULL;
}

void push(struct Stack* s, int val) {
    struct Node* newNode = createNode(val);
    newNode->next = s->top;
    s->top = newNode;
}

void pop(struct Stack* s) {
    if (!s->top) {
        printf("Stack Underflow\n");
        return;
    }
    struct Node* temp = s->top;
    s->top = s->top->next;
    free(temp);
}

void peekStack(struct Stack* s) {
    if (!s->top) printf("Stack is empty\n");
    else printf("Top element: %d\n", s->top->data);
}

void displayStack(struct Stack* s) {
    struct Node* temp = s->top;
    while (temp) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

// ---------------- QUEUE USING LINKED LIST ----------------
struct Queue {
    struct Node* front;
    struct Node* rear;
};

void initQueue(struct Queue* q) {
    q->front = NULL;
    q->rear = NULL;
}

void enqueue(struct Queue* q, int val) {
    struct Node* newNode = createNode(val);
    if (!q->rear) {
        q->front = q->rear = newNode;
        return;
    }
    q->rear->next = newNode;
    q->rear = newNode;
}

void dequeue(struct Queue* q) {
    if (!q->front) {
        printf("Queue Underflow\n");
        return;
    }
    struct Node* temp = q->front;
    q->front = q->front->next;
    if (!q->front) q->rear = NULL;
    free(temp);
}

void peekQueue(struct Queue* q) {
    if (!q->front) printf("Queue is empty\n");
    else printf("Front element: %d\n", q->front->data);
}

void displayQueue(struct Queue* q) {
    struct Node* temp = q->front;
    while (temp) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}

int main() {
    printf("=== STACK OPERATIONS ===\n");
    struct Stack s;
    initStack(&s);
    
    push(&s, 10);
    push(&s, 20);
    push(&s, 30);
    displayStack(&s);
    pop(&s);
    displayStack(&s);
    peekStack(&s);

    printf("\n=== QUEUE OPERATIONS ===\n");
    struct Queue q;
    initQueue(&q);
    
    enqueue(&q, 1);
    enqueue(&q, 2);
    enqueue(&q, 3);
    displayQueue(&q);
    dequeue(&q);
    displayQueue(&q);
    peekQueue(&q);
    
    // Free memory
    struct Node *stemp, *snext;
    stemp = s.top;
    while (stemp) {
        snext = stemp->next;
        free(stemp);
        stemp = snext;
    }
    
    struct Node *qtemp, *qnext;
    qtemp = q.front;
    while (qtemp) {
        qnext = qtemp->next;
        free(qtemp);
        qtemp = qnext;
    }

    return 0;
}
```

---

#### **Sample Output:**
```cpp
=== STACK OPERATIONS ===
30 -> 20 -> 10 -> NULL
20 -> 10 -> NULL
Top element: 20

=== QUEUE OPERATIONS ===
1 -> 2 -> 3 -> NULL
2 -> 3 -> NULL
Front element: 2
```

---

#### **Conclusion:**
- Stack implemented using linked list supports dynamic push and pop operations with efficient memory usage.
- Queue implemented using linked list allows dynamic enqueue and dequeue operations without size limitations.
- Both structures confirm their respective behaviors: LIFO for stack, FIFO for queue.
